1.多线程就是CPU开辟很多个线程来干活。
	多线程就是利用 等待 的时间，来执行任务
	多线程是建立在cpu的算力基础上，CPU如何很差，那么你开单线程和多线程其实时间差不多，线程不是说开得越多越好。
	单线程是按顺序来，多线程是并发的。
	
2.用户线程和守护线程
	setDeamon
	用户线程指 主线程或者子线程
	比如说，Main函数是一个主线程，Main函数里还start两个子线程，Main函数执行完毕，子线程线程仍然会运行。
	
	守护线程：
		主线程或者子线程跑完的时候，守护线程会自己关闭。
		
3.yield 让步
	跟sleep一样都是停止线程一段时间
	区别：
		sleep的唤醒是固定的，比如说 Thread.sleep(1000),唤醒时间就是 1秒以后。
		yield没有固定的时间，他是当其他的线程进入停止状态的时候，自动唤醒。
		
4.join 阻塞
	阻塞其他线程，强行让自己先运行完毕。
	

5.锁
	Synchronized
	加锁的地方一定是共用的，不论是方法还是对象
	锁代码块
	锁方法
		如果是继承 thread 需要把方法变成静态
		如果是实现runnable 则不需要把方法变成静态
		
6.线程间的通信
	notify wait
	案例：
	有两个线程，一群厨师，一群顾客，厨师每次只能炒一盘菜，必须是顾客吃完，才能继续炒下一道菜。
	要求：厨师不能同时炒两盘菜，顾客也不能同时吃两盘菜

7.线程池
	什么是线程池：放线程的一个类，也可以理解为是一个线程的集合。
	为什么会有线程池：
		让java更合理的使用线程。
		假设我们有五个线程放线程池来爬网页，如果第一线程因为网页的加载太慢而进入等待，那么线程池会启动第二个线程来继续爬。
		如果不用线程池，就需要一口气启动五个爬虫，有时明明一个爬虫就可以搞定，但是启动了五个就比较浪费资源。
		主要功能：
			合理的分配线程去工作。
	
	1.newCachedThreadPool
		线程池无限大
		工作的依据是，判断之前的线程是否使用完毕，如果使用完毕就用旧的线程。
		缺点：可能无限的开辟线程，造成内存溢出
	
	2.newFixedThreadPool
		线程池大小固定
		工作的依据是，执行固定的线程数，线程池如果只有三个线程，那么就只会有三个线程运行，不会多。
		
		
	3.newSingleThreadExecutor
		它只会用唯一的工作线程来执行任务。
	
	4.newScheduleThreadPool
		定时启动多线程
		优点：定时的启动线程
		使用场景：
			爬虫爬完一个网页，线程就会自己关闭，我希望线程关闭后会自动的再启动去工作。
	
	
	












